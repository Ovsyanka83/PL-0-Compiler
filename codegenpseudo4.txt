// this was written by TA Noelle without direction or suggestion from
// Professor Montagne, it is entirely possible that it contains errors
// if you find an error or you have any questions, please email me at 
// noellemidkiff@knights.ucf.edu

PROGRAM
	i = 1
	foreach symbol in symboltable
		if symbol is procedure
			symbol.value = i
			i++					
			emit a JMP (7, 0, 0, 0)
	BLOCK (0)
	for i = 0; code[i].opcode == 7 (jumps); i++
		code[i].m = the m value from that procedure's symbol table entry
	foreach line in code
		if line.opcode == 5 (calls)
			find procedure in the symbol table with value line.m
			line.m = the m value from that symbol table entry
	emit HALT (9, 0, 0, 3)

BLOCK (lex_level)
	numSymbols = 0
	numVars = 0
	if token == const
		do
			nextLexeme(st);
			numSymbols++
			unmark the const in the symbol table
			nextLexeme(st);
			nextLexeme(st);
			nextLexeme(st);
		while token == ,
		nextLexeme(st);
	if token == var
		do 
			nextLexeme(st);
			numVars++
			numSymbols++
			unmark the var in the symbol table
			nextLexeme(st);
		while token == ,
		nextLexeme(st);
	if token == procedure
		do
			nextLexeme(st);
			numSymbols++
			unmark the procedure in the symbol table
			nextLexeme(st);nextLexeme(st);
			BLOCK (lex_level + 1)
			emit RTN (2, 0, 0, 0)
			nextLexeme(st);
		while token == procedure
	update the symbol table entry for this procedure (current procedure) M = current code index
	emit INC (6, 0, 0, 3 + numVars)
	STATEMENT (lex_level)
	mark the last numSymbols number of unmarked symbols

STATEMENT (lex_level)
	if token == ident
		save the symbol table index of the var entry unmarked and closest in lex_level
		nextLexeme(st);
		nextLexeme(st);
		EXPRESSION (0, lex_level)
		emit STO (4, 0, L comes from the symbol table, M comes from the symbol table)
	if token == call
		nextLexeme(st);
		save the symbol table index of the procedure entry unmarked and closest in lex_level
		emit CAL (5, 0, L = lex_level - L from the symbol table, M = value from the symbol table entry)
		nextLexeme(st);
	if token == begin
		nextLexeme(st);
		STATEMENT (lex_level)
		whlie token == ;
			nextLexeme(st);
			STATEMENT (lex_level)
		nextLexeme(st);
	if token == if
		nextLexeme(st);
		CONDITION (lex_level)
		save the code index for jpc
		emit JPC (8, 0, 0, 0)
		nextLexeme(st);
		STATEMENT (lex_level)
		if token == else
			nextLexeme(st);
			save the current code index for jmp
			emit JMP (7, 0, 0, 0)
			fix the jpc from earlier, savedCodeIndexForJPC.M = currentcodeindex
			STATEMENT (lex_level)
			fix the jmp from earlier, savedCodeIndexForJMP.M = currentcodeindex
		else (ie there was no "else" keyword)
			fix the jpc from earlier, savedCodeIndexForJPC.M = currentcodeindex
	if token == while
		nextLexeme(st);
		save the code index for condition
		CONDITION (lex_level)
		nextLexeme(st);
		save the code index for jump
		emit JPC (8, 0, 0, 0)
		STATEMENT (lex_level)
		emit JMP (7, 0, 0, savedCodeIndexForCondition)
		fix the JPC from earlier, savedCodeIndexForJump.M = currentcodeindex
	if token == read
		nextLexeme(st);
		save the symbol table index of the var entry unmarked and closest to current lex_level
		nextLexeme(st);
		emit READ (9, 0, 0, 2)
		emit STO (4, 0, L = lex_level - L from the symbol table, M comes from the symbol table)
	if token == write
		nextLexeme(st);
		EXPRESSION (lex_level)
		emit WRITE (9, 0, 0, 1)
		nextLexeme(st);
		
CONDITION (lex_level)
	if token == odd
		nextLexeme(st);
		EXPRESSION (0, lex_level)
		emit ODD (15, 0, 0, 0)
	else
		EXPRESSION (0, lex_level)
		if token == =
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit EQL (17, 0, 0, 1)
		if token == <>
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit NEQ (18, 0, 0, 1) 
		if token == <
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit LSS (19, 0, 0, 1)
		if token == <=
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit LEQ (20, 0, 0, 1)
		if token == >
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit GTR (21, 0, 0, 1)
		if token == >=
			nextLexeme(st);
			EXPRESSION (1, lex_level)
			emit GEQ (22, 0, 0, 1)

EXPRESSION (regtoendupin = int where answer should go, lex_level)
	if token == +
		nextLexeme(st);
	if token == -
		nextLexeme(st);
		TERM (regtoendupin, lex_level)
		emit NEG (10, regtoendupin, 0, 0)
		while token == + || -
			if token == +
				nextLexeme(st);
				TERM (regtoendupin + 1, lex_level)
				emit ADD (11, regtoendupin, regtoendupin, regtoendupin + 1)
			if token == -
				nextLexeme(st);
				TERM (regtoendupin + 1, lex_level)
				emit SUB (12, regtoendupin, regtoendupin, regtoendupin + 1)
		return
	TERM (regtoendupin, lex_level)
	while token == + || -
		if token == +
			nextLexeme(st);
			TERM (regtoendupin + 1, lex_level)
			emit ADD (11, regtoendupin, regtoendupin, regtoendupin + 1)
		if token == -
			nextLexeme(st);
			TERM (regtoendupin + 1, lex_level)
			emit SUB (12, regtoendupin, regtoendupin, regtoendupin + 1)
			
TERM (regtoendupin, lex_level)
	FACTOR (regtoendupin, lex_level)
	while token == * || /
		if token == *
			nextLexeme(st);
			FACTOR (regtoendupin + 1, lex_level)
			emit MUL (13, regtoendupin, regtoendupin, regtoendupin + 1)
		if token == /
			nextLexeme(st);
			FACTOR (regtoendupin + 1, lex_level)
			emit DIV (14, regtoendupin, regtoendupin, regtoendupin + 1)

FACTOR (regtoendupin, lex_level)
	if token == ident
		save the symbol table index of the var or const entry unmarked and closest in lex_level
		if token == const
			emit LIT (1, regtoendupin, 0, value from the symbol table)
		if token == var
			emit LOD (3, regtoendupin, L = lex_level - L from the symbol table, m from the symbol table)
		nextLexeme(st);
	else if token == number
		emit LIT (1, regtoendupin, 0, number value)
		nextLexeme(st);
	else
		nextLexeme(st);
		EXPRESSION (regtoendupin, lex_level)
		nextLexeme(st);

void emit(int op, int r, int l, int m)
{
	if (cx > CODE_SIZE)
		error too much code
	else
	{
		code[cx].op = op;
		code[cx].r = r;
		code[cx].l = l;
		code[cx].m = m;
		cx++;
	}
}