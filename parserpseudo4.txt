// this was written by TA Noelle without direction or suggestion from
// Professor Montagne, it is entirely possible that it contains errors
// if you find an error or you have any questions, please email me at 
// noellemidkiff@knights.ucf.edu

PROGRAM
	add to symbol table (kind 3, "main", 0, lexlevel 0, m 0, unmarked)
	BLOCK (0)
	if token != .
		error

BLOCK (lexlevel)
	numSymbols = 0;
	numSymbols += CONST-DECLARATION (lexlevel)
	numSymbols += VAR-DECLARATION (lexlevel)
	numSymbols += PROCEDURE-DECLARATION (lexlevel + 1)
	STATEMENT (lexlevel)
	mark the last numSymbols number of unmarked symbols

returns numConsts CONST-DECLARATION (lexlevel)
	if token == const
		do
			nextLexeme(st);
			if token != ident
				error
			save ident name
			if the ident name is already in the symbol table unmarked and at the same lexlevel
				error
			nextLexeme(st);
			if token != =
				error
			nextLexeme(st);
			if token != number
				error
			add to the symbol table (kind 1, saved name, number is current token, lexlevel, m 0, unmarked)
			nextLexeme(st);
		while token == ,
		if token != ;
			error
		nextLexeme(st);

returns numVars VAR-DECLARATION (lexlevel)
	if token == var
		numVars = 0
		do
			numVars++
			nextLexeme(st);
			if token != ident
				error
			if the ident name is already in the symbol table unmarked and at the same lexlevel
				error
			add to symbol table (kind 2, name is current token, val 0, lexlevel, m var# + 2, unmarked)
			nextLexeme(st);
		while token == ,
		if token != ;
			error
		nextLexeme(st);
		
returns numProcedures PROCEDURE-DECLARATION (lexlevel)
	if token == procedure
		do
			nextLexeme(st);
			if token != ident
				error
			if ident is already in the symbol table unmarked and at the same level
				error
			add to the symbol table (kind 3, ident, val 0, lexlevel, m 0, unmarked)
			nextLexeme(st);
			if token != ;
				error
			nextLexeme(st);
			BLOCK(lexlevel)
			if token != ;
				error
			nextLexeme(st);
		while token == procedure
		
STATEMENT (lexlevel)
	if token == ident
		search the symbol table working backwards find the latest unmarked var with the desired name
		if you can't find one
			error
		nextLexeme(st);
		if token != :=
			error
		nextLexeme(st);
		EXPRESSION (lexlevel)
		return
	if token == call
		nextLexeme(st);
		search the symbol table working backwards find the latest unmarked procedure with the desired 
		if you can't find one
			error
		nextLexeme(st);
		return
	if token == begin
		nextLexeme(st);
		STATEMENT (lexlevel)
		while token == ;
			nextLexeme(st);
			STATEMENT (lexlevel)
		if token != end
			error
		nextLexeme(st);
		return
	if token == if
		nextLexeme(st);
		CONDITION (lexlevel)
		if token != then
			error
		nextLexeme(st);
		STATEMENT (lexlevel)
		if token == else
			nextLexeme(st);
			STATEMENT (lexlevel)
		return
	if token == while
		nextLexeme(st);
		CONDITION (lexlevel)
		if token != do
			error
		nextLexeme(st);
		STATEMENT (lexlevel)
		return
	if token == read
		nextLexeme(st);
		search the symbol table working backwards to find the latest unmarked var with the desired name
		if you can't find one
			error
		nextLexeme(st);
		return
	if token == write
		nextLexeme(st);
		EXPRESSION (lexlevel)
		return
	return
	
CONDITION (lexlevel)
	if token == odd
		nextLexeme(st);
		EXPRESSION (lexlevel)
	else
		EXPRESSION (lexlevel)
		if token != = <> < <= > >=
			error
		nextLexeme(st);
		EXPRESSION (lexlevel)
		
EXPRESSION (lexlevel)
	if token == + -
		nextLexeme(st);
	TERM (lexlevel)
	while token == + -
		nextLexeme(st);
		TERM (lexlevel)

TERM (lexlevel)
	FACTOR (lexlevel)
	while token == * /
		nextLexeme(st);
		FACTOR (lexlevel)

FACTOR (lexlevel)
	if token == ident
		search through the symbol table working backwards to find the latest unmarked var or const with the desired name
		if you can't find one
			error
		nextLexeme(st);
	else if token == number
		nextLexeme(st);
	else if token == (
		nextLexeme(st);
		EXPRESSION (lexlevel)
		if token != )
			error
		nextLexeme(st);
	else
		error